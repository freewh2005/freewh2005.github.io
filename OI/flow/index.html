
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../lca/">
      
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.24">
    
    
      
        <title>网络流模型与应用 - My Docs</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6543a935.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="My Docs" class="md-header__button md-logo" aria-label="My Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            My Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              网络流模型与应用
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="My Docs" class="md-nav__button md-logo" aria-label="My Docs" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    My Docs
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../home/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    wh2005's Old Blog for OI
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            wh2005's Old Blog for OI
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../lca/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    lca
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    网络流模型与应用
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    网络流模型与应用
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      前言：
    </span>
  </a>
  
    <nav class="md-nav" aria-label="前言：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cf720b-cactusophobia" class="md-nav__link">
    <span class="md-ellipsis">
      CF720B Cactusophobia
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#noi2006" class="md-nav__link">
    <span class="md-ellipsis">
      [NOI2006]最大获利
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tjoi2011" class="md-nav__link">
    <span class="md-ellipsis">
      [TJOI2011]卡片
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sdoi2014lis" class="md-nav__link">
    <span class="md-ellipsis">
      [SDOI2014]LIS
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zjoi2009" class="md-nav__link">
    <span class="md-ellipsis">
      [ZJOI2009]狼和羊的故事
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      方格取数问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      最少割边最小割
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#happiness" class="md-nav__link">
    <span class="md-ellipsis">
      [国家集训队]happiness
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      文理分科
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#icpc-beijing-2006" class="md-nav__link">
    <span class="md-ellipsis">
      [ICPC-Beijing 2006]狼抓兔子
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ctsc1999" class="md-nav__link">
    <span class="md-ellipsis">
      [CTSC1999]家园/星际转移问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#noi2008" class="md-nav__link">
    <span class="md-ellipsis">
      [NOI2008]志愿者招募
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2017" class="md-nav__link">
    <span class="md-ellipsis">
      [六省联考2017]寿司餐厅
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      无限之环
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#airport" class="md-nav__link">
    <span class="md-ellipsis">
      Airport
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      资料：
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      前言：
    </span>
  </a>
  
    <nav class="md-nav" aria-label="前言：">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cf720b-cactusophobia" class="md-nav__link">
    <span class="md-ellipsis">
      CF720B Cactusophobia
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#noi2006" class="md-nav__link">
    <span class="md-ellipsis">
      [NOI2006]最大获利
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tjoi2011" class="md-nav__link">
    <span class="md-ellipsis">
      [TJOI2011]卡片
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sdoi2014lis" class="md-nav__link">
    <span class="md-ellipsis">
      [SDOI2014]LIS
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zjoi2009" class="md-nav__link">
    <span class="md-ellipsis">
      [ZJOI2009]狼和羊的故事
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      方格取数问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      最少割边最小割
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#happiness" class="md-nav__link">
    <span class="md-ellipsis">
      [国家集训队]happiness
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      文理分科
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#icpc-beijing-2006" class="md-nav__link">
    <span class="md-ellipsis">
      [ICPC-Beijing 2006]狼抓兔子
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ctsc1999" class="md-nav__link">
    <span class="md-ellipsis">
      [CTSC1999]家园/星际转移问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#noi2008" class="md-nav__link">
    <span class="md-ellipsis">
      [NOI2008]志愿者招募
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2017" class="md-nav__link">
    <span class="md-ellipsis">
      [六省联考2017]寿司餐厅
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      无限之环
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#airport" class="md-nav__link">
    <span class="md-ellipsis">
      Airport
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      资料：
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  <h1>网络流模型与应用</h1>

<h3 id="_1"><strong>前言：</strong></h3>
<hr />
<p>由于网络流的建模比较多样，所以想将最近训练到的常见网络流建模记录下，以此巩固所学。</p>
<h4 id="cf720b-cactusophobia"><strong>CF720B Cactusophobia</strong></h4>
<hr />
<p>给一棵 $n$ 个点的仙人掌（无向联通图的一种，每条边最多属于一个环），边上有颜色，让你求出把这棵仙人掌删边成一棵 $n$ 个节点的树后剩余颜色种类最多时的颜色种类数。</p>
<p>解析：不难发现要删成一棵树，那么就需要每个环各自删一条边，使得剩余颜色数最大。</p>
<p>考虑对每个颜色建一个虚拟节点，超级源向它们连边并有一个的流量。然后对于一个点双连通分量，看作为一个节点，这个点双内所拥有的颜色对应的节点都向其连边。</p>
<p>为保证每个点双都只能拥有其 <strong>点数减一</strong> 条边，即 $siz-1$ ，那么这个点双对应的节点连向超级汇的边所拥有的容量只能为 $siz-1$。</p>
<p>跑一遍最大流即可，因为要求颜色种类最多。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e5+9;
int n,m,head[N],tot;
struct pp{int nxt,to,c;}g[N];
void add(int u,int v,int w){
    g[++tot].nxt=head[u],g[tot].to=v,g[tot].c=w,head[u]=tot;
}
vector&lt;int &gt;dcc[N];
int cnt,low[N],dfn[N],num,s[N],top,siz[N];
void tarjan(int u){
    dfn[u]=low[u]=++num,s[++top]=u;int flag=0;
    for(int i=head[u];i!=-1;i=g[i].nxt){
        int v=g[i].to;
        if(!dfn[v]){
            tarjan(v);
            low[u]=min(low[v],low[u]);
            if(low[v]&gt;=dfn[u]){
                ++cnt;siz[cnt]=1;
                do{
                    dcc[cnt].push_back(s[top]);siz[cnt]++;
                }while(s[top--]!=v);
                dcc[cnt].push_back(u);
            }
        }
        else low[u]=min(low[u],dfn[v]);
    }
}
int hd[N],cur[N];
struct Edge{int nxt,to,val;}G[N];
void Add(int u,int v,int w){
    G[++tot].nxt=hd[u],G[tot].to=v,G[tot].val=w,hd[u]=tot;
}
void inAdd(int u,int v,int w){Add(u,v,w);Add(v,u,0);return ;}
int vis[N],S,T;
void dfs(int u,int fa,int id){
    vis[u]=2;
    for(int i=head[u];i!=-1;i=g[i].nxt){
        int v=g[i].to;if(v==fa) continue;
        if(vis[v]){
            inAdd(g[i].c,id+m,1);
            if(vis[v]==1) dfs(v,u,id);
        }
    }
}
int dep[N];
int bfs(){
    for(int i=0;i&lt;=T;i++) dep[i]=0;
    queue&lt;int&gt;q;dep[S]=1;q.push(S); 
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=hd[u];i!=-1;i=G[i].nxt){
            int v=G[i].to;
            if(G[i].val&amp;&amp;!dep[v]){dep[v]=dep[u]+1;q.push(v);}
        }
    }
    return dep[T];
}
int Dinic(int u,int flow){
    if(u==T) return flow;
    int ct=0;
    for(int &amp;i=cur[u];i!=-1;i=G[i].nxt){
        int v=G[i].to;
        if(G[i].val&amp;&amp;dep[v]==dep[u]+1){
            int res=Dinic(v,min(flow,G[i].val));
            G[i].val-=res,G[i^1].val+=res;
            ct+=res,flow-=res;
        }
        if(!flow) break;
    }
    if(!ct) dep[u]=0;
    return ct;
}
int mxflow(){
    int ans=0;
    while(bfs()){
        for(int i=0;i&lt;=T;i++) cur[i]=hd[i];
        ans+=Dinic(S,1e9);
    }
    return ans;
}
int main(){
    memset(head,-1,sizeof(head));tot=0;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=m;i++){
        int u,v,w;scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);add(u,v,w);add(v,u,w);
    }
    top=0,cnt=0,num=0;
    tarjan(1);tot=-1;
    memset(hd,-1,sizeof(hd));
    memset(vis,0,sizeof(vis));
    for(int i=1;i&lt;=cnt;i++){
        for(int j=0;j&lt;dcc[i].size();j++) vis[dcc[i][j]]=1;
        dfs(dcc[i][0],0,i);
        for(int j=0;j&lt;dcc[i].size();j++) vis[dcc[i][j]]=0;
    }
    S=0,T=m+cnt+1;
    for(int i=1;i&lt;=m;i++) inAdd(S,i,1);
    for(int i=1;i&lt;=cnt;i++) inAdd(m+i,T,siz[i]-1);
    printf(&quot;%d\n&quot;,mxflow());
    return 0;
}
</code></pre>
<h4 id="noi2006"><strong>[NOI2006]最大获利</strong></h4>
<hr />
<p><a href="https://www.luogu.com.cn/problem/P4174">题面链接</a></p>
<p>涉及建模：<a href="https://www.cnblogs.com/wuyiqi/archive/2012/03/12/2391960.html">最大权闭合子图</a></p>
<p>这是最小割的典型应用。先讲下闭合图的定义，一个有向图是闭合图当且仅当每个属于闭合图的点 <strong>所有后继都在闭合图内</strong>。</p>
<p>对应的逻辑关系就是若闭合图上一个点被选择，那么它的所有后继都必须被选择。</p>
<p>最大权闭合子图就是从原图中选出一个闭合子图，使得子图内点权之和最大。（点权可正可负）</p>
<p>在本题中，将每个群体用户和基站都看作一个点，群体用户 $i$ 的点权为 $C_i$，基站 $j$ 点权为 $-P_j$。</p>
<p>给出的关系可以看做用户群体 $i$ 向基站 $a_i$ 和 $b_i$ 连边，而我们要做的就是求这张图的最大权闭合子图。</p>
<p>对于最大权闭合子图的求解其实是个套路，也是最小割的典型应用。</p>
<p>其建图方式如下：</p>
<blockquote>
<p>构造一个源点S，汇点T。我们将S与所有权值为正的点（即盈利）连一条容量为其权值的边，将所有权值为负的点（即代价）与T连一条容量为其权值的绝对值的边，原来的边将其容量定为正无穷。</p>
</blockquote>
<p>可以证明，一条简单割划分将原图划分为与 S 联通和与 T 联通的两个子图，与 S 联通的子图除去 S 就是一个闭合子图。</p>
<p>当简单割为最小割时，与 S 联通的闭合子图就是最大权闭合子图。</p>
<p>对于这道题而言，就是：</p>
<p>如果割掉用户的边，那么就舍弃掉一部分收益，可以看做损失。</p>
<p>如果割掉中转站的边，那么就付出一定代价，可以看做损失。</p>
<p>最后用总收益( $\sum{C_i}$ )减去最小割(最大流)就是答案</p>
<p>至于证明，可以去上面那个链接看看，也可以看看自己的。</p>
<p>证明：总盈利（权值为正的点权和）$-$ 最小割的容量 $=$ 最大权闭合子图。</p>
<p>首先，易知与 $S$ 联通的子图除去 $S$ 即为闭合子图，并且最小割一定是简单割，我们要证的是当割为最小割是，该闭合子图权最大。</p>
<p>不妨令与 $S$ 联通的子图为 $M$ ，与 $T$ 联通的子图为 $N$ 。</p>
<p>$M$ 的权值和就是   $M$ 中权值为正的点权和 $x_1$   加上  $M$ 中权值为负的点权和。 为方便，记 $M$ 中权值为负的点权和的绝对值为 $y_1$,则 $M$ 的权值和 $W = x_1 - y_1$</p>
<p>此时图中简单割的容量 $C$ 为 $N$ 中权值为正的点权和 $x_2$  加上 $M$ 中点权为负的点权和的绝对值 $y_1$，即 $C = x_2 + y_1$</p>
<p>那么 $W+C = x_1+x_2  =  sum$ ，$sum$ 表示盈利之和。</p>
<p>所以 $W = sum - C$ ，当 $C$ 取到最小（即最小割时）， $W$ 为最大权闭合子图的权值。</p>
<p>可参考<a href="https://wenku.baidu.com/view/986baf00b52acfc789ebc9a9.html">《最小割模型在信息学竞赛中的应用》</a></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 2e5+9;
const int inf = 1e9;
int n,m,p[N],head[N],tot,cur[N];
struct pp{int nxt,to,val;}g[N&lt;&lt;1];
void add(int u,int v,int w){
    g[++tot].nxt=head[u],g[tot].to=v,g[tot].val=w,head[u]=tot;
}
void inadd(int u,int v,int w){add(u,v,w);add(v,u,0);return ;}
int S,T,dep[N];
int bfs(){
    for(int i=0;i&lt;=T;i++) dep[i]=0;
    queue&lt;int&gt;q;while(!q.empty()) q.pop();
    q.push(S);dep[S]=1;
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i!=-1;i=g[i].nxt){
            int v=g[i].to;
            if(g[i].val&amp;&amp;!dep[v]){dep[v]=dep[u]+1;q.push(v);}
        }
    }
    return dep[T];
}
int Dinic(int u,int flow){
    if(u==T) return flow;
    int cnt=0;
    for(int &amp;i=cur[u];i!=-1;i=g[i].nxt){
        int v=g[i].to;
        if(g[i].val&amp;&amp;dep[v]==dep[u]+1){
            int res=Dinic(v,min(flow,g[i].val));
            g[i].val-=res,g[i^1].val+=res;
            flow-=res,cnt+=res;
        }
        if(!flow) break;
    }
    if(!cnt) dep[u]=0;
    return cnt;
}
int mxflow(){
    int ans=0;
    while(bfs()){
        for(int i=0;i&lt;=T;i++) cur[i]=head[i];
        ans+=Dinic(S,inf);
    }
    return ans;
}
int main(){
    memset(head,-1,sizeof(head));tot=-1;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);S=0,T=n+m+1;
    for(int i=1;i&lt;=n;i++){scanf(&quot;%d&quot;,&amp;p[i]);inadd(m+i,T,p[i]);}
    int sum=0;
    for(int i=1;i&lt;=m;i++){
        int a,b,c;scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);sum+=c;
        inadd(i,m+a,inf);inadd(i,m+b,inf);inadd(S,i,c);
    }
    printf(&quot;%d\n&quot;,sum-mxflow());    
    return 0;
}
</code></pre>
<h4 id="tjoi2011"><strong>[TJOI2011]卡片</strong></h4>
<hr />
<p><a href="https://www.luogu.com.cn/problem/P2065">题面链接</a></p>
<p>题意有问题，看了半天，才发现求的是能匹配的组数。</p>
<p>考虑如果直接暴力连边可能到达 $n^2$ 级别的边数，所以面临超时的危险。解决方案也不难，只要通过共有的质数来简化建边策略即可。</p>
<p>我们对红色卡上的数向它所含有的所有质数连一条容量为 $1$ 的边，对所有蓝色卡上的数从它所含有的所有质数处连出一条容量为 $1$ 的边，再分别连上超级源和超级汇，跑一遍最大流即可。</p>
<p>注意：这样的建边是将原来从两个集合内分别枚举造成 $n^2$ 的边数优化到 $n\log n$ 级别的边数，因为一个数所含有的质因子最多 $\log$ 个。这样优化建图的方式也很常见，通过新建（与两者都有关系的）节点来简化边数。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 509;
const int M = 3e3+9;
int T,n,m,a[N],b[N];
int cnt,head[M],tot,cur[M],dep[M];
map&lt;int ,int &gt;mp;
int New(int x){if(mp[x]) return mp[x];mp[x]=++cnt;return cnt;}
int s,t;
struct pp{int nxt,to,val;}g[M*10];
void add(int u,int v,int w){g[++tot].nxt=head[u],g[tot].to=v,g[tot].val=w,head[u]=tot;}
void inadd(int u,int v,int w){add(u,v,w);add(v,u,0);}
int bfs(){
    memset(dep,0,sizeof(dep));dep[s]=1;
    queue&lt;int &gt;q;while(!q.empty()) q.pop();
    q.push(s);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i!=-1;i=g[i].nxt){
            int v=g[i].to;
            if(g[i].val&amp;&amp;!dep[v]){dep[v]=dep[u]+1;q.push(v);}
        }
    } 
    return dep[t];
}
int Dinic(int u,int flow){
    if(u==t) return flow;
    int cnt=0;
    for(int &amp;i=cur[u];i!=-1;i=g[i].nxt){
        int v=g[i].to;
        if(dep[v]==dep[u]+1&amp;&amp;g[i].val){
            int res=Dinic(v,min(flow,g[i].val));
            g[i].val-=res,g[i^1].val+=res;
            cnt+=res,flow-=res;
        }
        if(!flow) break;
    }
    if(!cnt) dep[u]=0;
    return cnt;
}
int mxflow(){
    int ans=0;
    while(bfs()){
        for(int i=0;i&lt;=t;i++) cur[i]=head[i];
        ans+=Dinic(s,1e9);
    }
    return ans;
}

int main(){
    scanf(&quot;%d&quot;,&amp;T);
    while(T--){
        memset(head,-1,sizeof(head));tot=-1;
        cnt=0;mp.clear();
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
        for(int i=1;i&lt;=m;i++) scanf(&quot;%d&quot;,&amp;b[i]);
        cnt=n;
        for(int i=1;i&lt;=n;i++){
            for(int j=2;j*j&lt;=a[i];j++)
                if(!(a[i]%j)){
                    inadd(i,New(j),1);
                    while(!(a[i]%j)) a[i]/=j;
                    if(a[i]==1) break;
                }
            if(a[i]!=1) inadd(i,New(a[i]),1);
        }
        for(int i=1;i&lt;=m;i++){
            for(int j=2;j*j&lt;=b[i];j++)
                if(!(b[i]%j)){
                    if(mp[j]) inadd(mp[j],cnt+i,1);
                    while(!(b[i]%j)) b[i]/=j;
                    if(b[i]==1) break;
                }
            if(b[i]!=1&amp;&amp;mp[b[i]]) inadd(mp[b[i]],cnt+i,1); 
        }
        s=0,t=cnt+m+1;
        for(int i=1;i&lt;=n;i++) inadd(s,i,1);
        for(int i=1;i&lt;=m;i++) inadd(cnt+i,t,1);
        printf(&quot;%d\n&quot;,mxflow());
    }
    return 0;
}
</code></pre>
<h4 id="sdoi2014lis"><strong>[SDOI2014]LIS</strong></h4>
<hr />
<p><a href="https://www.luogu.com.cn/problem/P3308">题面链接</a></p>
<p>首先明确我们第一小问要做的是删去一些数，使得不存在和原来相同长度的最长上升子序列。</p>
<p>有一个很 naive 的想法，就是将能在最长上升子序列上的数与它的后继连边，建立超级源向所有最长上升子序列的开头连边，所有最长升上子序列的结尾向超级汇连边。那我们就是求以最小的代价是源和汇不连通，即最小割。</p>
<p>可你发现，这种做法在具体实现的时候我们无法给每条边确定权值，也就是说，删掉一条边的时候，我们并不知道具体该删哪个数。这就使得我们该使用拆点的技巧。</p>
<p>奇技淫巧之拆点：将一个点拆成一个进，一个出，这两个点连边边权为删除这个点的代价，其余点之间的连边为 inf ，这就很好的解决了这个问题。</p>
<p>接下来求最小割即可。</p>
<p>这还没完呢！本题还要求输出字典序最小的方案！</p>
<p>字典序最小指的是 $C$ 值小的越前面越好，与序列长度无关。</p>
<p>下面先介绍如何输出方案。</p>
<p>首先引入最小割的可行边和必须边。</p>
<p>“一条边是最小割的可行边，就表明这条边存在于某一种最小割中。”</p>
<p>如何判定$(u,v)$是否是可行边：</p>
<ol>
<li>
<p>$(u,v)$ 必须满流。（没什么好说的。数值上，最小割等于最大流，显然割满流的边才有可能是最小割）</p>
</li>
<li>
<p>在残量网络中，$u,v$ 在不经过反向边的情况下不连通，即不存在从 $u$ 到 $v$ 的增广路径。</p>
</li>
</ol>
<p>我们只需要看看从 $u$ 到 $v$ 能不能 $bfs$ 就好了，因为最大流最小割定理，如果 $u$ 到 $v$ 还能增广，那么它就不是决定最大流流量的那条边，即它不可能是最小割上的边。</p>
<p>至于字典序最小，那么我们就从 $C$ 值最小的边开始枚举，然后进行退流，即撤销它的贡献，相当于把这条边割掉。我们一直这么做直到 $S$ 和 $T$ 不连通为止。</p>
<p>下面直接引用题解中的话：</p>
<blockquote>
<p>所以我们的答案就一定是最小割的可行边，我们开始构造这个最小割集</p>
<p>我们按照边的权值排序，如果一条边是可行边，我们就需要把这条边加入答案</p>
<p>同时选择了这条边的话我们就得排除和这条边等价的那些边的影响</p>
<p>这条边等价的那些边显然会存在于 $S$ 到 $u$ 和 $v$ 到 $T$ 的路径上，我们只需要从 $u$ 向 $S$ ，$T$ 向 $v$ 退流,把那些满流的边的流量清掉</p>
<p>退流的话跑一遍 $dinic$ 就好了</p>
<p>同时注意优化一下 $dinic$ 的常数，有一点卡常</p>
</blockquote>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
const int N = 709;
const int M = 2e5+9;
const ll inf = 1e15;
int Tt,n,a[N];ll b[N];
int dp[N],st[N],top,vis[N];
int in[N],ot[N],S,T,head[M],tot;
struct pp{int nxt,to;ll val;}g[M&lt;&lt;1];
void add(int u,int v,ll w){g[++tot].nxt=head[u],g[tot].to=v,g[tot].val=w,head[u]=tot;}
void inadd(int u,int v,ll w){add(u,v,w);add(v,u,0);return ;}
int dep[M],cur[M];
int bfs(int s,int t){
    memset(dep,0,sizeof(dep));dep[s]=1;
    queue&lt;int&gt;q;while(!q.empty()) q.pop();q.push(s);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i!=-1;i=g[i].nxt){
            int v=g[i].to;
            if(g[i].val&amp;&amp;!dep[v]){dep[v]=dep[u]+1;q.push(v);}
        }
    }
    return dep[t];
}
ll Dinic(int u,ll flow){
    if(u==T) return flow;
    ll cnt=0;
    for(int &amp;i=cur[u];i!=-1;i=g[i].nxt){
        int v=g[i].to;
        if(dep[v]==dep[u]+1&amp;&amp;g[i].val){
            ll res=Dinic(v,min(flow,g[i].val));
            g[i].val-=res,g[i^1].val+=res;
            cnt+=res,flow-=res;
        }
        if(!flow) break;
    }
    if(!cnt) dep[u]=0;
    return cnt;
}
ll mxflow(){
    ll ans=0;
    while(bfs(S,T)){
        for(int i=0;i&lt;=2*n+1;i++) cur[i]=head[i];
        ans+=Dinic(S,inf); 
    }
    return ans;
}
struct node{ll val;int id;}c[N];
bool cmp(node x,node y){return x.val&lt;y.val;}
int ans[N],e;
void Del(int S,int T){
    while(bfs(S,T)){
        for(int i=0;i&lt;=2*n+1;i++) cur[i]=head[i];
        ll y=Dinic(S,inf);
    }
    return ;
}
int main(){
    scanf(&quot;%d&quot;,&amp;Tt);
    while(Tt--){
        memset(head,-1,sizeof(head));tot=-1;
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1;i&lt;=n;i++) scanf(&quot;%d&quot;,&amp;a[i]);
        for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;b[i]);
        for(int i=1;i&lt;=n;i++){scanf(&quot;%lld&quot;,&amp;c[i].val);c[i].id=i;}
        top=0;st[0]=0;
        for(int i=1;i&lt;=n;i++){
            if(!top||st[top]&lt;a[i]) st[++top]=a[i],dp[i]=top;
            else{
                int l=1,r=top,ps=top;
                while(l&lt;=r){
                    int mid=(l+r)&gt;&gt;1;
                    if(st[mid]&gt;=a[i]) r=mid-1,ps=mid;
                    else l=mid+1;
                }
                st[ps]=a[i],dp[i]=ps;
            }
        }
        memset(vis,0,sizeof(vis));int len=top;
        S=0,T=2*n+1;
        for(int i=1;i&lt;=n;i++){in[i]=2*i-1,ot[i]=2*i;inadd(in[i],ot[i],b[i]);}
        for(int i=n;i&gt;=1;i--){
            if(dp[i]==len) vis[i]=1;
            if(vis[i]){
                for(int j=1;j&lt;i;j++)
                    if(dp[j]+1==dp[i]&amp;&amp;a[j]&lt;a[i]){
                        vis[j]=1;
                        inadd(ot[j],in[i],inf);
                    }
            }
            if(dp[i]==len) inadd(ot[i],T,inf);
            if(dp[i]==1) inadd(S,in[i],inf);
        }
        printf(&quot;%lld &quot;,mxflow());e=0;
        sort(c+1,c+n+1,cmp);
        for(int i=1;i&lt;=n;i++){
            int u=in[c[i].id],v=ot[c[i].id];
            if(g[2*c[i].id-2].val==0){
                if(!bfs(u,v)){
                    g[2*c[i].id-2].val=0,g[2*c[i].id-1].val=0;
                    S=u,T=0;Del(S,T);
                    S=2*n+1,T=v;Del(S,T);
                    ans[++e]=c[i].id;
                }
            }
        }
        printf(&quot;%d\n&quot;,e);sort(ans+1,ans+e+1);
        for(int i=1;i&lt;=e;i++) printf(&quot;%d &quot;,ans[i]);puts(&quot;&quot;);
    }
    return 0;
}
</code></pre>
<h4 id="zjoi2009"><strong>[ZJOI2009]狼和羊的故事</strong></h4>
<hr />
<p>题意简述：</p>
<p>有 $n\times m$ 的网格图，每个格子有一个值 $0/1/2$ （三选一），我们可以在格子边缘建栅栏，一单位长度代价为 $1$，求使得 $1$，$2$不再联通的方案数。</p>
<p>题解：</p>
<p>可以转化为最小割，相邻两个格子间建边。对 $1$ 和 $2$ 的点分别与超级源、超级汇连边，为防止与超级源汇的连边会成为最小割的一部分，可以直接把边权赋为 $inf$ 。接下来目的就是使 $S$ ， $T$ 不连通，这就可以直接上最小割了（这真是裸的最小割。。） </p>
<p>注意 $0$ 与 $0$ 的格子间也需要连边，因为这样有可能会使答案更优（反正连上超级源汇后就直接满足最小割的定义了，留给电脑瞎跑吧，反正是最小割）。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e2+9;
const int N2 = 1e5+9;
const int inf = 1e9;
int n,m,a[N][N],head[N2],tot;
struct pp{int nxt,to,val;}g[N2*10];
void add(int u,int v,int w){
    g[++tot].nxt=head[u],g[tot].to=v,g[tot].val=w,head[u]=tot;
}
void Iadd(int u,int v,int w){add(u,v,w);add(v,u,0);return ;}
int c(int x,int y){return (x-1)*m+y;}
void I(int x,int y,int nx,int ny){
    if(nx&gt;n||nx&lt;1||ny&gt;m||ny&lt;1) return ;
    Iadd(c(x,y),c(nx,ny),1);return ;
}
int S,T,cur[N2],dep[N2];
int bfs(){
    memset(dep,0,sizeof(dep));dep[S]=1;
    queue&lt;int&gt;q;while(!q.empty()) q.pop();
    q.push(S);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i!=-1;i=g[i].nxt){
            int v=g[i].to;
            if(g[i].val&amp;&amp;!dep[v]){dep[v]=dep[u]+1;q.push(v);}
        }
    }
    return dep[T];
}
int Dinic(int u,int flow){
    if(u==T) return flow;
    int cnt=0;
    for(int &amp;i=cur[u];i!=-1;i=g[i].nxt){
        int v=g[i].to;
        if(g[i].val&amp;&amp;dep[v]==dep[u]+1){
            int res=Dinic(v,min(flow,g[i].val));
            g[i].val-=res,g[i^1].val+=res;
            cnt+=res,flow-=res;
        }
        if(!flow) break;
    }
    if(!cnt) dep[u]=0;
    return cnt;
}
int mxflow(){
    int ans=0;
    while(bfs()){
        for(int i=S;i&lt;=T;i++) cur[i]=head[i];
        ans+=Dinic(S,inf);
    }
    return ans;
}
int main(){
    memset(head,-1,sizeof(head));tot=-1;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;a[i][j]);
    for(int x=1;x&lt;=n;x++)
        for(int y=1;y&lt;=m;y++){I(x,y,x+1,y);I(x,y,x,y+1);I(x,y,x-1,y);I(x,y,x,y-1);}
    S=0,T=n*m+1;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++){
            if(a[i][j]==1) Iadd(S,c(i,j),inf);
            if(a[i][j]==2) Iadd(c(i,j),T,inf);
        }
    printf(&quot;%d\n&quot;,mxflow());
    return 0;
}
</code></pre>
<h4 id="_2"><strong>方格取数问题</strong></h4>
<hr />
<p><a href="https://www.luogu.com.cn/problem/P2774">题面链接</a></p>
<p>与骑士共存同套路题。</p>
<p>可以注意到这类带有方格的题目注意关联点的特殊奇偶性，（有的是奇偶优化建图，有的是就是这么做）</p>
<p>虽然题目中说的是求和的最大，但请不要天真的认为是最大流，它同样可以是最小割。</p>
<p>因为最大盈利 $=$ 总盈利之和 $-$ 最小代价。</p>
<p>不难发现，在本题中对于点 $(i,j)$ 与它有关联的点 $(i,j+1),(i+1,j),(i-1,j),(i,j-1)$ 满足若 $(i+j)\%2=1$ ，那么与它有关的点的行列之和就只能是 $(i+j)\%2=0$。</p>
<p>这种情况下如果没有点权，相当于就是二分图选择最大独立集，使得所选点集中任意两点都没有边相连。</p>
<p>但由于本题有点权，所以并不使用二分图来做。</p>
<p>那我们就可以对所有 $i+j$ 为奇数的点与超级源连边，所有 $i+j$ 为偶数的点向超级汇连边，这两种类型的边点权都为 $a[i][j]$。对于有关联的点则连边容量为 $inf$  ，那么最小割肯定为简单割。</p>
<p>当我们割掉一条边后，表示我们舍弃与这条边相邻点的贡献。由于最小割是简单割，所以对于割完后的图，与源汇有边相连的点是被我们选择的点，这些点间一定不连通（不然怎么叫割呢？），当这个割最小时，我们抛弃的代价就越小。用总盈利和减去后，就是我们所要的答案。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e2+9;
const int N2 = 1e4+9;
const int inf = 2e9;
int n,m,a[N][N],head[N2],tot;
struct pp{int nxt,to,val;}g[N2*10];
void add(int u,int v,int w){
    g[++tot].nxt=head[u],g[tot].to=v,g[tot].val=w,head[u]=tot;
}
void E(int u,int v,int w){add(u,v,w);add(v,u,0);return ;}
int c(int x,int y){return (x-1)*m+y;}
int S,T,dep[N2],cur[N2];
int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};
int bfs(){
    memset(dep,0,sizeof(dep));dep[S]=1;
    queue&lt;int&gt;q;q.push(S);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i!=-1;i=g[i].nxt){
            int v=g[i].to;
            if(g[i].val&amp;&amp;!dep[v]){dep[v]=dep[u]+1;q.push(v);}
        }
    }
    return dep[T];
}
int Dinic(int u,int flow){
    if(u==T) return flow;
    int cnt=0;
    for(int &amp;i=cur[u];i!=-1;i=g[i].nxt){
        int v=g[i].to;
        if(g[i].val&amp;&amp;dep[v]==dep[u]+1){
            int res=Dinic(v,min(flow,g[i].val));
            g[i].val-=res,g[i^1].val+=res;
            cnt+=res,flow-=res;
        }
        if(!flow) break;
    }
    if(!cnt) dep[u]=0;
    return cnt;
}
int mxflow(){
    int ans=0;
    while(bfs()){
        for(int i=S;i&lt;=T;i++) cur[i]=head[i];
        ans+=Dinic(S,inf);
    }
    return ans;
}
int main(){
    memset(head,-1,sizeof(head));tot=-1;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);S=0,T=n*m+1;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++) scanf(&quot;%d&quot;,&amp;a[i][j]);
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++){
            if((i+j)%2){
                E(S,c(i,j),a[i][j]);
                for(int k=0;k&lt;4;k++){
                    int nx=i+dx[k],ny=j+dy[k];
                    if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m) continue;
                    E(c(i,j),c(nx,ny),inf);
                }
            }
            else E(c(i,j),T,a[i][j]);
        }
    int sum=0;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++) sum+=a[i][j];
    printf(&quot;%d\n&quot;,sum-mxflow());
    return 0;
}
</code></pre>
<h4 id="_3"><strong>最少割边最小割</strong></h4>
<hr />
<p>不是具体的某道题，就只是一个应用，字面意思，选出最小割使得割边最少。</p>
<p>相信对 [SDOI2004]LIS 的印象够深刻吧，那么可行边集的定义应该还记得，可行边就是满流并且 $u$ 到 $v$ 无增广路的边，可行边集就是所有最小割中割边的并集。</p>
<p>那么如果要求最小割最少割边呢？对可行边集中每条边容量重新定义为 $1$ ，非可行边容量赋为 $inf$ ，重新跑一遍最小割即可。</p>
<h4 id="happiness"><strong>[国家集训队]happiness</strong></h4>
<hr />
<p><a href="https://www.luogu.com.cn/problem/P1646">题面链接</a></p>
<p>最小割应用之处理集合间的矛盾关系（名称可能不准确） <a href="https://oi-wiki.org/graph/flow/min-cut/#_11">问题模型</a></p>
<p>有 $n$ 个物品和两个集合 $A,B$ ，如果将一个物品放入 $A$ 集合会花费 $a_i$ ，放入 $B$ 集合会花费 $b_i$ ；还有若干个形如 $(u_i,v_i,w_i)$ 限制条件，表示如果 $u_i$ 和 $v_i$ 同时不在一个集合会花费 $w_i$ 。每个物品必须且只能属于一个集合，求最小的代价。</p>
<p>这是一个经典的 <strong>二者选其一</strong> 的最小割题目。我们对于每个集合设置源点 $S$ 和汇点 $T$ ，第 $i$ 个点由 $S$ 连一条容量为 $a_i$ 的边、向 $T$ 连一条容量为 $b_i$ 的边。对于限制条件 $i$ ，我们在 $u_i,v_i$ 之间连容量为 $w_i$ 的双向边。</p>
<p>注意到当源点和汇点不相连时，代表这些点都选择了其中一个集合。如果将连向 $S$ 或 $T$ 的边割开，表示不放在 $A$ 或 $B$ 集合，如果把物品之间的边割开，表示这两个物品不放在同一个集合。</p>
<p>最小割就是最小代价。</p>
<p>本题就是这套模型的基本应用，当然还有一种解法也颇为巧妙，将在下一道题中介绍。</p>
<p>我在写这道题是还没有接触到这个模型，只是看到题解中那种解方程的思想，但两者本质相同，结合这道题，先用朴素的思想讲解。</p>
<p><a href="https://imgchr.com/i/rAgi4S"><img alt="rAgi4S.png" src="https://s3.ax1x.com/2020/12/11/rAgi4S.png" /></a></p>
<p>这种解方程的做法其实就是模型的基本思路，只不过这道题不能直接套用模型，因为当 $i,j$ 属于同一个集合才会有贡献。所以还是得通过对边赋权的方式，或者费用提前/退回的方式来进行处理，与解方程大致相似。</p>
<p>这里有人可能对于为什么这个模型中是建双向边有些疑惑，对此，我的说法是：最小割准确来讲并不能说用最小的代价使 $S,T$ 不连通，而是得讲成用最小的代价使得 $S,T$ 之间无增广路。在上述图中，最小割并不会对于中间两条边全部选择，这就是有无增广路和是否联通的区别，即这些边有向，我们只要把它们割到从 $S$ 无法到 $T$ 就可以了。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e2+9;
const int N2 = 1e5+9;
const int inf = 1e9;
int n,m,p[N][N];
int a[N][N],b[N][N];
int head[N2],tot,cur[N2],dep[N2];
struct pp{int nxt,to,val;}g[N2*10];
int c(int x,int y){return (x-1)*m+y;}
int S,T;
void add(int u,int v,int w){
    g[++tot].nxt=head[u],g[tot].to=v,g[tot].val=w,head[u]=tot;
}
void E(int u,int v,int w){add(u,v,w);add(v,u,0);return ;}
int bfs(){
    memset(dep,0,sizeof(dep));dep[S]=1;
    queue&lt;int&gt;q;while(!q.empty()) q.pop();q.push(S);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i!=-1;i=g[i].nxt){
            int v=g[i].to;
            if(g[i].val&amp;&amp;!dep[v]){dep[v]=dep[u]+1;q.push(v);}
        }
    }
    return dep[T];
}
int Dinic(int u,int flow){
    if(u==T) return flow;
    int cnt=0;
    for(int &amp;i=cur[u];i!=-1;i=g[i].nxt){
        int v=g[i].to;
        if(dep[v]==dep[u]+1&amp;&amp;g[i].val){
            int res=Dinic(v,min(g[i].val,flow));
            g[i].val-=res,g[i^1].val+=res;
            cnt+=res,flow-=res;
        }
        if(!flow) break;
    }
    if(!cnt) dep[u]=0;
    return cnt;
}
int mxflow(){
    int ans=0;
    while(bfs()){
        for(int i=S;i&lt;=T;i++) cur[i]=head[i];
        ans+=Dinic(S,inf);
    }
    return ans;
}
int main(){
    memset(head,-1,sizeof(head));tot=-1;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);S=0,T=n*m+1;int sum=0;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++){scanf(&quot;%d&quot;,&amp;a[i][j]);sum+=a[i][j];a[i][j]*=2;}
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++){scanf(&quot;%d&quot;,&amp;b[i][j]);sum+=b[i][j];b[i][j]*=2;}
    memset(p,0,sizeof(p));
    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;=m;j++){
            int x;scanf(&quot;%d&quot;,&amp;x);sum+=x;
            p[i][j]+=x;a[i][j]+=x,a[i+1][j]+=x;
        }
    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;=m;j++){
            int x;scanf(&quot;%d&quot;,&amp;x);sum+=x;
            p[i][j]+=x;b[i][j]+=x,b[i+1][j]+=x;
        }
    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;=m;j++){
            E(c(i,j),c(i+1,j),p[i][j]);E(c(i+1,j),c(i,j),p[i][j]);
        }
    memset(p,0,sizeof(p));
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;m;j++){
            int x;scanf(&quot;%d&quot;,&amp;x);sum+=x;
            p[i][j]+=x;a[i][j]+=x,a[i][j+1]+=x;
        }
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;m;j++){
            int x;scanf(&quot;%d&quot;,&amp;x);sum+=x;
            p[i][j]+=x;b[i][j]+=x,b[i][j+1]+=x;
        }
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;m;j++){
            E(c(i,j),c(i,j+1),p[i][j]);E(c(i,j+1),c(i,j),p[i][j]);
        }
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++){
            E(S,c(i,j),a[i][j]);E(c(i,j),T,b[i][j]);
        }
    int wrt=mxflow();sum*=2;
    printf(&quot;%d\n&quot;,(sum-wrt)/2);
    return 0;
}
</code></pre>
<h4 id="_4"><strong>文理分科</strong></h4>
<hr />
<p><a href="https://www.luogu.com.cn/problem/P4313">题面链接</a></p>
<p>这道题本质和上面那道相同，只不过这里提供一种新的解法。</p>
<p>新建一个节点 $x$ 表示相邻的 $4$ 个人和自己都选择文科。那么从源点流向 $x$ 一条容量为 同选文科的满意度 的边  $e$ 。再从 $x$ 向这 $5$ 个人连一条流量为 $inf$ 的边。对于理科则更改下方向以相同方式处理。</p>
<p>这个做法是从学长的博客中看到的。<a href="https://siyuan.blog.luogu.org/solution-p1646">学长的博客，题目是上一道题happiness</a></p>
<p>考虑这样做的正确性，因为如果 $e$ 不被割掉意味着这 $5$ 个人所代表的点必须和 $x$ 在同一个集合内，即收获同选文科的满意值。原因是 $x$ 与其它 $5$ 个点的连边权值是 $inf$ ，如果两者不在同一个集合，那么这条为 $inf$ 的边一定会被割掉，这显然是不可能的。</p>
<p>若 $e$ 被割掉，那么就没有流流向 $x$ ，即它不会对最小割（即最大流）产生贡献。原因还是那句话，边是有向边，最小割的意义是以最小的代价使得 $S$ 没有到 $T$ 的增广路，即这个 $x$ 将不会对答案产生贡献。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e2+9;
const int N2 = 1e5+9;
const int inf = 1e9;
int n,m,head[N2],tot;
int dep[N2],cur[N2],S,T;
int c(int x,int y){return (x-1)*m+y;}
int dx[5]={1,-1,0,0,0};
int dy[5]={0,0,1,-1,0};
struct pp{int nxt,to,val;}g[N2*10];
void add(int u,int v,int w){
    g[++tot].nxt=head[u],g[tot].to=v,g[tot].val=w,head[u]=tot;
}
void E(int u,int v,int w){add(u,v,w);add(v,u,0);return ;}
int bfs(){
    memset(dep,0,sizeof(dep));dep[S]=1;
    queue&lt;int&gt;q;while(!q.empty()) q.pop();q.push(S);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i!=-1;i=g[i].nxt){
            int v=g[i].to;
            if(g[i].val&amp;&amp;!dep[v]){dep[v]=dep[u]+1;q.push(v);}
        }
    }
    return dep[T];
}
int Dinic(int u,int flow){
    if(u==T) return flow;
    int cnt=0;
    for(int &amp;i=cur[u];i!=-1;i=g[i].nxt){
        int v=g[i].to;
        if(dep[v]==dep[u]+1&amp;&amp;g[i].val){
            int res=Dinic(v,min(g[i].val,flow));
            g[i].val-=res,g[i^1].val+=res;
            cnt+=res,flow-=res;
        }
        if(!flow) break;
    }
    if(!cnt) dep[u]=0;
    return cnt;
}
int mxflow(){
    int ans=0;
    while(bfs()){
        for(int i=S;i&lt;=T;i++) cur[i]=head[i];
        ans+=Dinic(S,inf);
    }
    return ans;
}
int main(){
    memset(head,-1,sizeof(head));tot=-1;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);S=0,T=3*n*m+1;int sum=0;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++){
            int x;scanf(&quot;%d&quot;,&amp;x);E(S,c(i,j),x);sum+=x;
        }
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++){
            int x;scanf(&quot;%d&quot;,&amp;x);E(c(i,j),T,x);sum+=x;
        }
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++){
            int a;scanf(&quot;%d&quot;,&amp;a);sum+=a;
            int ps=c(i,j)+n*m;E(S,ps,a);
            for(int k=0;k&lt;5;k++){
                int x=i+dx[k],y=j+dy[k];
                if(x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue;
                E(ps,c(x,y),inf);
            }
        }
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;=m;j++){
            int a;scanf(&quot;%d&quot;,&amp;a);sum+=a;
            int ps=c(i,j)+2*n*m;E(ps,T,a); 
            for(int k=0;k&lt;5;k++){
                int x=i+dx[k],y=j+dy[k];
                if(x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue;
                E(c(x,y),ps,inf);
            }
        }
    int wrt=mxflow();
    printf(&quot;%d\n&quot;,sum-wrt);
    return 0;
}
</code></pre>
<hr />
<h4 id="icpc-beijing-2006"><strong>[ICPC-Beijing 2006]狼抓兔子</strong></h4>
<p><a href="https://www.luogu.com.cn/problem/P4001">题面链接</a></p>
<p>最小割转最短路的应用。</p>
<p>这种题用 $Dinic$ 满足正确性，但是在点数和边数极多的情况下，$Dinic$ 的效率就不尽人意了。</p>
<p>不难发现，对于 <strong>平面无向图</strong> 来说，它的最小割是连续的，在这道题中体现的更加明显。</p>
<p>这是张网格图，按照转对偶图的套路，我们把在对偶图上 / 穿过原来某条边的 / 边的边权 / 赋为 / 原图中被穿过边的边权（~~断句好评~~）。</p>
<p>那么~~显然~~，我们的最小割是一条连续的线将整个网格分割成两部分，原因是如果不能一笔画将这个网格隔开，那么就一定会存在一条从左上到右下的路径（这里有两个特殊条件导致这个结果 1.能画成平面图 2.图是无向的，图有向很容易找出反例）。</p>
<p>那么这条割在边缘该怎么话呢？（即超级源和超级汇该怎么干）</p>
<p>这个其实还是很容易的，看下面这个图就懂了，因为如果要割开这个网格图，那对偶图上的路径的起止点必须一个在左下，一个在右上。（请自行证明）</p>
<p><img alt="" src="https://cdn.luogu.com.cn/upload/image_hosting/xw1k1aog.png" /></p>
<p>也可以这样理解（尽管不是这道题）：</p>
<p><img alt="" src="https://cdn.luogu.com.cn/upload/image_hosting/jr1wbolg.png" /></p>
<p>那么你要最小割，就是新图上 $S$ 到 $T$ 的最短路径。</p>
<p>本题结束。</p>
<p><a href="https://www.cnblogs.com/qzqzgfy/p/5578785.html">平面图转对偶图</a></p>
<p><a href="https://www.cnblogs.com/jinkun113/p/4682827.html">题解及资料</a></p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long
#define pi pair&lt;ll ,int &gt;
const int N = 1009;
const int N2 = 2e6+9;
int n,m,head[N2],tot; 
int S,T;
struct pp{int nxt,to;ll val;}g[N2&lt;&lt;2];
void add(int u,int v,ll w){
    g[++tot].nxt=head[u],g[tot].to=v,g[tot].val=w,head[u]=tot;
}
void E(int u,int v,ll w){add(u,v,w);add(v,u,w);return ;}
int it[N][N],ot[N][N],cnt;
ll dis[N2];int vis[N2];
priority_queue&lt;pi &gt;q;
void dij(){
    memset(vis,0,sizeof(vis));
    memset(dis,-1,sizeof(dis));dis[S]=0;
    while(!q.empty()) q.pop();q.push(make_pair(0,S));
    while(!q.empty()){
        int u=q.top().second;q.pop();
        if(vis[u]) continue;vis[u]=1;
        for(int i=head[u];i!=-1;i=g[i].nxt){
            int v=g[i].to;
            if(dis[v]==-1||dis[v]&gt;dis[u]+g[i].val){
                dis[v]=dis[u]+g[i].val;
                q.push(make_pair(-dis[v],v));
            }        
        }
    }
    return ;
}
int main(){
    memset(head,-1,sizeof(head));tot=0;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);S=0,T=(n-1)*(m-1)*2+1,cnt=0;
    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;m;j++) it[i][j]=++cnt,ot[i][j]=++cnt;
    for(int i=1;i&lt;=n;i++)
        for(int j=1;j&lt;m;j++){
            ll x;scanf(&quot;%lld&quot;,&amp;x);
            if(i==n) E(ot[i-1][j],T,x);
            else{
                if(i==1) E(S,it[i][j],x);
                else E(ot[i-1][j],it[i][j],x);
            }
        }
    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;=m;j++){
            ll x;scanf(&quot;%lld&quot;,&amp;x);
            if(j==m) E(S,it[i][j-1],x);
            else{
                if(j==1) E(T,ot[i][j],x);
                else E(it[i][j-1],ot[i][j],x);
            }
        }
    for(int i=1;i&lt;n;i++)
        for(int j=1;j&lt;m;j++){
            ll x;scanf(&quot;%lld&quot;,&amp;x);
            E(ot[i][j],it[i][j],x);
        }
    dij();
    printf(&quot;%lld\n&quot;,dis[T]);
    return 0;
}
</code></pre>
<hr />
<h4 id="ctsc1999"><strong>[CTSC1999]家园/星际转移问题</strong></h4>
<p><a href="https://www.luogu.com.cn/problem/P2754">题面链接</a></p>
<p>再点开题解的一瞬间，我意识到可以二分出最短时间，对于该时间下建一张图，跑一遍网络最大流来确定最多有多少人能转移到月球，本题结束。</p>
<p>建图是有讲究的，采用分层图的思想，每个时间为一层，按照航线先后顺序连边，建立超级源和超级汇即可（因为时间有先后，不能晚到的人坐上早到的车，所以得分层图）。</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 109;
const int N2 = 16e3+9;
const int inf = 1e9;
int n,m,k,head[N2],tot;
struct pp{int nxt,to,val;}g[N2*10];
void add(int u,int v,int w){
    g[++tot].nxt=head[u],g[tot].to=v,g[tot].val=w,head[u]=tot;
}
void E(int u,int v,int w){add(u,v,w);add(v,u,0);return ;}
int ht[N],nt[N],a[N][N],S,T;
void init(int t){
    memset(head,-1,sizeof(head));tot=-1;
    S=0,T=n*(t+1)+1;
    for(int i=1;i&lt;=m;i++){
        int ps=0;
        for(int j=1;j&lt;=t;j++){
            ps=ps%nt[i]+1;int nps=ps%nt[i]+1;
            E((j-1)*n+a[i][ps],j*n+a[i][nps],ht[i]);
        }
    }
    for(int i=0;i&lt;t;i++) for(int j=1;j&lt;=n;j++) E(i*n+j,(i+1)*n+j,inf);
    for(int i=0;i&lt;=t;i++) E(S,i*n+1,inf);
    for(int i=1;i&lt;=t+1;i++) E(i*n,T,inf);
    return ;
}
int dep[N2],cur[N2];
int bfs(){
    memset(dep,0,sizeof(dep));dep[S]=1;
    queue&lt;int &gt;q;q.push(S);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i!=-1;i=g[i].nxt){
            int v=g[i].to;
            if(g[i].val&amp;&amp;!dep[v]){dep[v]=dep[u]+1;q.push(v);}
        }
    }
    return dep[T];
}
int Dinic(int u,int flow){
    int cnt=0;if(u==T) return flow;
    for(int &amp;i=cur[u];i!=-1;i=g[i].nxt){
        int v=g[i].to;
        if(g[i].val&amp;&amp;dep[v]==dep[u]+1){
            int res=Dinic(v,min(flow,g[i].val));
            g[i].val-=res,g[i^1].val+=res;
            cnt+=res,flow-=res;
        }
        if(!flow) break;
    }
    if(!cnt) dep[u]=0;
    return cnt;
}
int mxflow(){
    int ans=0;
    while(bfs()){
        for(int i=S;i&lt;=T;i++) cur[i]=head[i];
        ans+=Dinic(S,inf);
    }
    return ans;
}
int check(int x){
    init(x);
    int p=mxflow();
    if(p&gt;=k) return 1;
    return 0;
}
int main(){
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);n+=2;
    for(int i=1;i&lt;=m;i++){
        scanf(&quot;%d%d&quot;,&amp;ht[i],&amp;nt[i]);
        for(int j=1;j&lt;=nt[i];j++){
            scanf(&quot;%d&quot;,&amp;a[i][j]);a[i][j]+=1;if(!a[i][j]) a[i][j]=n;
        }
    }
    int l=1,r=1000,ans=0;
    while(l&lt;=r){
        int mid=(l+r)&gt;&gt;1;
        if(check(mid)) r=mid-1,ans=mid;
        else l=mid+1;
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
</code></pre>
<h4 id="noi2008"><strong>[NOI2008]志愿者招募</strong></h4>
<hr />
<p><a href="https://www.luogu.com.cn/problem/P3980">题面链接</a></p>
<p>这是一道比较经典的建模题，在题解区有一篇不错的<a href="https://www.luogu.com.cn/blog/user9012/solution-p3980">题解</a></p>
<p>源点连第一天，汇点连最后一天，容量为 $inf$ 费用为 $0$</p>
<p>这样跑网络流是沿时间流的（就是依次解决每一天的问题）</p>
<p>然后每一天向后一天连一条容量为 $inf-a[i]$，费用为 $0$ 的边</p>
<p>为什么容量为 $inf-a[i]$，这就相当于少了 $a[i]$，得用带权边补全 $inf$ ，（这个流量需要被下面的带权边补齐的，并且它一定会被补齐，因为最大流量一定是 $inf$ 跑满的）</p>
<p>然后将每一类志愿者 $s[i]$ 与 $t[i]+1$ 连一条容量为 $inf$ 花费为 $c[i]$ 的边</p>
<p>当连续干的人不够时，就得充钱使劲往里塞人，补全 $inf$ 的容量</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define ll long long 
const int N = 1e5+9;
const int inf = 1e9;
int n,m,head[N],tot;
struct pp{int nxt,to,val;ll cst;}g[N&lt;&lt;1];
void add(int u,int v,int fl,ll w){
    g[++tot].nxt=head[u],g[tot].to=v,g[tot].val=fl,g[tot].cst=w,head[u]=tot;
}
void El(int u,int v,int fl,ll w){add(u,v,fl,w);add(v,u,0,-w);return ;}
int S,T;ll ans,dis[N];
int pre[N],lst[N],flw[N],flag[N];
queue&lt;int &gt;q;
bool spfa(int s,int t){
    while(!q.empty()) q.pop();
    for(int i=s;i&lt;=t;i++) dis[i]=-1,flw[i]=0,flag[i]=0;
    dis[s]=0,flag[s]=1,pre[t]=-1,flw[s]=inf;q.push(s);
    while(!q.empty()){
        int u=q.front();q.pop();flag[u]=0;
        for(int i=head[u];i!=-1;i=g[i].nxt){
            int v=g[i].to;
            if(g[i].val){
                if(dis[v]==-1||dis[v]&gt;dis[u]+g[i].cst){
                    dis[v]=dis[u]+g[i].cst,pre[v]=u,lst[v]=i;
                    flw[v]=min(flw[u],g[i].val);
                    if(!flag[v]){flag[v]=1;q.push(v);}
                }
            }
        }
    }
    return pre[t]!=-1;
}
void MCMF(){
    ans=0;
    while(spfa(S,T)){
        int now=T,fl=flw[T];ans+=dis[T]*fl;
        while(now!=S){
            g[lst[now]].val-=fl;
            g[lst[now]^1].val+=fl;
            now=pre[now];
        }
    }
}
int main(){
    memset(head,-1,sizeof(head));tot=-1;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);S=0,T=n+2;El(S,S+1,inf,0);El(T-1,T,inf,0);
    for(int i=1;i&lt;=n;i++){int x;scanf(&quot;%d&quot;,&amp;x);El(i,i+1,inf-x,0);}
    for(int i=1;i&lt;=m;i++){int s,t,w;scanf(&quot;%d%d%d&quot;,&amp;s,&amp;t,&amp;w);El(s,t+1,inf,w);}
    MCMF();printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
<h4 id="2017"><strong>[六省联考2017]寿司餐厅</strong></h4>
<hr />
<p><strong>题意简述：</strong></p>
<p>有 $n$ 种寿司，第 $i$ 种寿司的类型为 $a_i$</p>
<p>如果你吃了第 $i$ 种到第 $j$ 种寿司，你会得到 $\sum d_{i,j}(i\le j)$ 的收益。</p>
<p>如果你吃了 $c,c &gt; 0$ 种类型为 $x$ 的寿司，你会付出 $mx^2+cx$ 的代价 $m\in{0,1}$。</p>
<p>最大化收益与代价的差。</p>
<p><strong>简要题解：</strong></p>
<p>相当于选了 $d_{i,j}$ 就一定要选 $d_{i+1,j}$ 和 $d_{i,j-1}$ ，选了一个点，就必须选它的后继，让我们最大化收益和代价的差</p>
<p>这不是最大权闭合子图是啥</p>
<p><strong>最大权闭合子图</strong></p>
<p>定义就是选了 $u$ ，必须要选 $u$ 的所有后继</p>
<p>有时候，我们要为了一个收益很高的点而被迫选了一个不优的后继</p>
<p>常见的做法是最小割</p>
<p>我们认为最终得到的图中，与 $S$ 联通的节点是被我们选择的</p>
<p>若一个物品连向 $S$ 边权为 $a$ ，连向 $T$ 边权为 $0$ ，则表示选择它有 $a$ 的收益</p>
<p>若一个物品连向 $S$ 边权为 $0$ ，连向 $T$ 边权为 $b$ ，则表示选择它要花费 $b$ 的代价</p>
<p>实际过程中，连向 $S,T$ 的边不一定其中有一条一定是 $0$ ，这里只是方便理解，但流量一定为正（若收益是负的，可以想 $T$ 连一条正边表示选它要花费多少）</p>
<p>前驱连向后继一条 $+\infty$ 流量的边，这样我们的最小割一定不会把这条边割开，也就是说选了前驱就一定得选后继，选了后继不一定要选前驱</p>
<p>好了，上面的建图跑最小割就可以了</p>
<p>这题其实挺板的</p>
<p>对于 $mx^2+cx$ 我们可以看成选了 $x$ 这一种食物（新建一个节点表示第 $x$ 种食物，$i$ 号寿司满足 $a[i]==x$ 向他连 $+\infty$ 的边）就会有 $mx^2$ 的代价，吃了一个属于第 $x$ 种的食物就要花 $x$ 的代价，新建节点和原节点分别想 $T$ 连边就行了</p>
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int inf = 1e9+7;
const int N = 1e2+9;

#define il inline
il char gc(){
    static char now[1&lt;&lt;20],*S,*T;
    if (T==S){
        T=(S=now)+fread(now,1,1&lt;&lt;20,stdin);
        if (T==S) return EOF;
    }
    return *S++;
}//getchar
il int read(){
    int res=0,sign=1;
    char c;
    while ((c=gc())&lt;'0'||c&gt;'9') if (c=='-') sign=-1;
    res=(c^48);
    while ((c=gc())&gt;='0'&amp;&amp;c&lt;='9') res=(res&lt;&lt;3)+(res&lt;&lt;1)+(c^48);
    return res*sign;
}//read a signed interger

int n,m,a[N],d[N][N];
int cnt,id[N][N];

int p[N];
void LSH(){
    for(int i=1;i&lt;=n;i++) p[i]=a[i];sort(p+1,p+n+1);int len=unique(p+1,p+n+1)-p-1;
    for(int i=1;i&lt;=n;i++) a[i]=lower_bound(p+1,p+len+1,a[i])-p;return ;
}

int head[N*N],tot;
struct pp{int nxt,to,flow;}g[N*N*32];
void add(int u,int v,int w){g[++tot].nxt=head[u],g[tot].to=v,g[tot].flow=w,head[u]=tot;return ;}
void E(int u,int v,int w){add(u,v,w);add(v,u,0);return ;}
int S,T,dep[N*N],cur[N*N];
queue&lt;int &gt;q;
bool bfs(){
    memset(dep,0,sizeof(dep));
    dep[S]=1;while(!q.empty()) q.pop();q.push(S);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int i=head[u];i!=-1;i=g[i].nxt){
            int v=g[i].to;
            if(!dep[v]&amp;&amp;g[i].flow){dep[v]=dep[u]+1;q.push(v);}
        }
    }
    return dep[T]&gt;0;
} 

int Dinic(int u,int flow){
    if(u==T) return flow;
    int cnt=0;
    for(int &amp;i=cur[u];i!=-1;i=g[i].nxt){
        int v=g[i].to;
        if(dep[v]==dep[u]+1&amp;&amp;g[i].flow&gt;0){
        //注意如果你要用 !cnt 则 dep[u]=0 的这个 trick 就一定要判 g[i].flow&gt;0 ，不然的话一旦送出了 0 流量的边，这个点就无法在本次循环中再走了，会陷入死循环 
            int res=Dinic(v,min(g[i].flow,flow));
            g[i].flow-=res,g[i^1].flow+=res;
            cnt+=res,flow-=res;
        }
        if(!flow) break;
    }
    if(!cnt) dep[u]=0;
    return cnt;
}

int maxflow(){
    int sum=0;
    while(bfs()){
        for(int i=S;i&lt;=T;i++) cur[i]=head[i];
        sum+=Dinic(S,inf);
    }
    return sum;
}

int main(){
    n=read(),m=read();
    for(int i=1;i&lt;=n;i++) a[i]=read();LSH();
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=n-i+1;j++) d[i][i+j-1]=read();
    }
    cnt=0;
    for(int i=1;i&lt;=n;i++)
        for(int j=i;j&lt;=n;j++) id[i][j]=++cnt;
    memset(head,-1,sizeof(head));tot=-1;
    S=0,T=cnt+n+1;
    for(int i=1;i&lt;=n;i++) E(id[i][i],cnt+a[i],inf);
    for(int i=1;i&lt;=n;i++) E(cnt+i,T,m*p[i]*p[i]);
    cnt+=n;
    for(int i=1;i&lt;=n;i++){
        for(int j=i;j&lt;=n;j++){
            if(j-1&gt;=i) E(id[i][j],id[i][j-1],inf);
            if(i+1&lt;=j) E(id[i][j],id[i+1][j],inf);
        }
    }
    for(int i=1;i&lt;=n;i++){
        if(p[a[i]]&gt;0) E(id[i][i],T,p[a[i]]);
        else E(S,id[i][i],-p[a[i]]);
    }
    for(int i=1;i&lt;=n;i++)
        for(int j=i;j&lt;=n;j++){
            if(d[i][j]&gt;0) E(S,id[i][j],d[i][j]);
            else E(id[i][j],T,-d[i][j]);
        }
    int ans=0;
    for(int i=1;i&lt;=n;i++)
        for(int j=i;j&lt;=n;j++) if(d[i][j]&gt;0) ans+=d[i][j];
    ans-=maxflow();
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
/*
g++ &quot;[六省联考2017]寿司餐厅&quot;.cpp -o A
*/
</code></pre>
<h4 id="_5"><strong>无限之环</strong></h4>
<hr />
<p><img alt="" src="https://cdn.luogu.com.cn/upload/image_hosting/uq8rr6ot.png" /></p>
<p><img alt="" src="https://cdn.luogu.com.cn/upload/image_hosting/bqz12mmp.png" /></p>
<h4 id="airport"><strong>Airport</strong></h4>
<hr />
<p><img alt="" src="https://cdn.luogu.com.cn/upload/image_hosting/8hxt8ybu.png" /></p>
<p><img alt="" src="https://cdn.luogu.com.cn/upload/image_hosting/m5o1fqwq.png" /></p>
<h4 id="_6"><strong>资料：</strong></h4>
<hr />
<p><a href="https://blog.csdn.net/cdqzoiers/article/details/53834908">网络流一般建模方式——最小割篇</a></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.081f42fc.min.js"></script>
      
    
  </body>
</html>